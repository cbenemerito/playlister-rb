require_relative 'lib/artist'
require_relative 'lib/song'
require_relative 'lib/genre'
require 'ERB'

def test(title, &b)
  begin
    if b
      result = b.call
      if result.is_a?(Array)
        puts "fail: #{title}"
        puts "      expected #{result.first} to equal #{result.last}"
      elsif result
        puts "pass: #{title}"
      else
        puts "fail: #{title}"
      end
    else
      puts "pending: #{title}"
    end
  rescue => e
    puts "fail: #{title}"
    puts e
  end
end

def assert(statement)
  !!statement
end

def assert_equal(actual, expected)
  if expected == actual
    true
  else
    [expected, actual]
  end
end

# Part 1: Object Models

# Create a Class for song, artist, and genre. Use an individual file for each class.
# These files should be placed within a lib directory and required on the top of
# any script that utilizes them (including this test script). Once required
# all the tests within this suite should pass.

# Artist Specs
test 'Can initialize an Artist' do
  assert Artist.new
end

test 'An artist can have a name' do
  artist = Artist.new
  artist.name = "Adele"
  assert_equal artist.name, "Adele"
end

test "An artist has songs" do
  artist = Artist.new
  artist.songs = []
  assert_equal artist.songs, []
end

test 'The Artist class can reset the artists that have been created' do
  assert Artist.reset_artists
  assert_equal Artist.count, 0
end

test 'The Artist class can keep track of artists as they are created' do
  Artist.reset_artists
  artist = Artist.new
  assert Artist.all.include?(artist)
end

test 'The Artist class can count how many artists have been created' do
  assert Artist.count
end

test 'artists have songs' do
  artist = Artist.new
  songs = (1..4).collect{|i| Song.new}
  artist.songs = songs

  assert_equal artist.songs, songs
end

test 'An artist can count how many songs they have' do
  artist = Artist.new
  songs = [Song.new, Song.new]
  artist.songs = songs

  assert_equal artist.songs_count, 2
end

test 'a song can be added to an artist' do
  artist = Artist.new
  song = Song.new
  artist.add_song(song)

  assert artist.songs.include?(song)
end

test 'artists have genres' do
  artist = Artist.new
  song = Song.new
  song.genre = Genre.new.tap{|g| g.name = "rap"}
  artist.add_song(song)

  assert artist.genres.include?(song.genre)
end

# Genre Specs
test 'Can initialize a genre' do
  assert Genre.new
end

test 'A genre has a name' do
  genre = Genre.new
  genre.name = 'rap'
  assert_equal genre.name, 'rap'
end

test 'A genre has many songs' do
  Genre.reset_hashes # added to reset changes made in previous tests
  genre = Genre.new.tap{|g| g.name = 'rap'} 
  [1,2].each do
    song = Song.new
    song.genre = genre
  end

  assert_equal genre.songs.count, 2
end

test 'A genre has many artists' do
  Genre.reset_hashes #added to reset changes made in previous tests
  genre = Genre.new.tap{|g| g.name = 'rap'}

  [1,2].each do
    artist = Artist.new
    song = Song.new
    song.genre = genre
    artist.add_song(song)
  end

  assert_equal genre.artists.count, 2
end

test 'A genres Artists are unique' do
  Genre.reset_hashes #added to reset changes made in previous tests
  genre = Genre.new.tap{|g| g.name = 'rap'}
  artist = Artist.new

  [1,2].each do
    song = Song.new
    song.genre = genre
    artist.add_song(song)
  end

  assert_equal genre.artists.count, 1
end

# Same behavior as Artists
test 'The Genre class can keep track of all created genres' do
  Genre.reset_genres # You must implement a method like this
  genres = [1..5].collect do |i|
    Genre.new
  end

  assert_equal Genre.all, genres
end

# Extra Credit
# Complete any song test that is pending (undefined).
# The functionality described must still be present to complete the assignment
# so even if you do not complete the pending specs, they must pass in my complete
# test suite. There's no way you'd be able to accomplish the site generation
# without your song class having this functionality, so go ahead and try
# to use assert and assert_equal to write some tests.

test 'Can initialize a song'
test 'A song can have a name'
test 'A song can have a genre'
test 'A song has an artist'

# Part 2: Site Generation Using ERB
# write a ruby script that parses the data within the data directory
# and uses the classes defined above to instantiate Song, Artist, and Genres
# for each file. These instances should be correctly associated to each other
# so that artist.genre will return a Genre object, etc.

# This script should additionally Generate a website that has the following sections:
# An index page that links to the two sections of the sites, artists and genres

  # site/index.html
    # links to artists.html
    # links to genres.html

  # This index page does not need to be generated by the application, you can just manually
  # create it.

# Templates should be generated via ERB files located in lib/views.

# site/artists.html
# The artist index must list all the artists. This list must be sorted alphabetically.
# In addition to the Artists name, the artists total song count should be displayed.
# The artist name should link to the artists individual page within site/artists.
# This page should also say how many Artists there are in total.

# artists/<artist>.html
# The script must generate an artist page for each individual artist that was created
# during import. An artists page should list the name of the artist along with their songs
# and genres. The songs and genres must link to the individual song and genre page.

  # M83 - 8 Songs
  #   1. Midnight City - Folk
  #   2. Kim & Jesse - Pop

# genres.html
# The genre index must list all the genres. This list must be sorted by the amount of songs.
# In addition to the Genres name, the total song and artist count should be listed along side it.
# The genre name should linke to the genres individual page within site/genres.

  # Folk: 8 Songs, 3 Artists

# genres/<genre>.html
# The script must generate a genre page for each individual genre that was created
# during import. A genres page should list the name of the songs, linking to the individual
# song and artists. Also include the total unique artists and song counts in the genre.

# Folk
  # M83 - Midnight City
  # Lady Gaga - Pokerface

# songs/<song>.html
# The song page should list all the available information on the song, it's artist and genre
# with the appropriate links.

# Extra Credit:
# Use a ruby module somewhere to refactor common functionality.

#clear the tracking arrays of actions used for tests abovea
Artist.reset_artists
Song.reset_songs
Genre.reset_genres
Genre.reset_hashes

path = 'data'
artist_names = [] #array to collect artist names and check for duplicates
genre_names = {} #hash to collect genre names and check for duplicates
artist = ''

Dir.foreach(path) do |filename| 
  next if filename.match(/^\./)
  parts = filename.split(" - ")
  parts2 = parts.last.split(" [")
  artist_name = parts.first
  song_name = parts2.first
  genre_name = parts2.last.gsub("].mp3", "")

  if !genre_names.include?(genre_name.to_sym)
    genre = Genre.new
    genre.name = genre_name
    genre_names[genre.name.to_sym] = genre
  else
    genre = genre_names[genre_name.to_sym]
  end

  if !artist_names.include?(artist_name)
    artist = Artist.new 
    artist.name = artist_name
    artist_names << artist_name
  end

  song = Song.new
  song.name = song_name
  song.artist = artist
  song.genre = genre
  artist.add_song(song)
  Genre.add_artist(artist, song)
end

html_path = 'site'

@artists = Artist.all
artists_erb = File.open('lib/views/artists.html.erb').read
artists_template = ERB.new(artists_erb)

File.open(html_path + '/artists.html', 'w+') do |f|
  f.write artists_template.result
end

#puts artists_template.result

@genres = Genre.all
genres_erb = File.open('lib/views/genres.html.erb').read
genres_template = ERB.new(genres_erb)

File.open(html_path + '/genres.html', 'w+') do |f|
  f.write genres_template.result
end

#puts genres_template.result

artist_erb = File.open('lib/views/artist.html.erb').read
artist_template = ERB.new(artist_erb)

@artists.each do |artist|
  full_html_path = html_path + '/artists/' + artist.name + '.html'
  File.open(full_html_path, 'w+') do |f|
    f.write artist_template.result(artist.to_binding)
  end
end

genre_erb = File.open('lib/views/genre.html.erb').read
genre_template = ERB.new(genre_erb)

@genres.each do |genre|
  full_html_path = html_path + '/genres/' + genre.name + '.html'
  File.open(full_html_path, 'w+') do |f|
    f.write genre_template.result(genre.to_binding)
  end
end

@songs = Song.all
song_erb = File.open('lib/views/song.html.erb').read
song_template = ERB.new(song_erb)

@songs.each do |song|
  full_html_path = html_path + '/songs/' + song.name + '.html'
  File.open(full_html_path, 'w+') do |f|
    f.write song_template.result(song.to_binding)
  end
end

